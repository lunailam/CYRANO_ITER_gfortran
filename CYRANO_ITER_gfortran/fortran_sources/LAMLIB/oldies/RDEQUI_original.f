      subroutine rdequi
      
      implicit none
      
      include 'PARDIM.COPY'
      include 'COMFIC.COPY'
      include 'COMFIN.COPY'
      include 'COMPLA.COPY'
      include 'COMGEO.COPY'
      include 'COMMAG.COPY'
      include 'COMSWE.COPY'
      include 'COMGDR.COPY'
      include 'COMIN2.COPY'
      include 'COMPHY.COPY'
      
C     Reads finite element coefficients of equilibrium distribution(s)
C     generated by QLFP code.
C     Case of bicubic finite elements in (v,x) constants of the motion,
C     i.e. there are 4 parameters per mesh node.   
      
      logical needrd
      
      integer kr, jv, ix, isp, ispa, i, j, igx, igv, j2
     ;, isrchfge
     
      double precision t, t1, t2, t3, s1, s2, xmax, vel, rhoq

      needrd = .false.
      do i = 1, nspgdr
      if(.not. maxwdr(i))needrd = .true.
      end do

      if(needrd)then
      write(NOFILE,*)
     ;'Reading grid data and equilibrium distribution(s) on unit ',unqlfp
      else
      write(NOFILE,*)'Reading grid data on unit ',unqlfp
      write(NOFILE,*)
     ;'A sampled Maxwellian will be used to generate dielectric response'
      end if
      write(NOFILE,*)'for species # ',(ispgdr(i),i=1,nspgdr)
     
c     Read QLFP grid parameters.
C     Modified according to Dirk's 'Philippe_interface.f' July 6, 1998.
C     Modified for easy radial interpolation September 18, 1998.
C     These modifs. are highlighted between 'c@' comment lines.

c     Current number of magnetic surfaces:
      nraddr = 0

c     Read radius-independent data:
c@    (read only once at beginning of the run) @      

c     Number of regions in x and in v:      
      read(unqlfp,*)nxgreg, nvgreg
c     Number of finite elements in each x region:      
      read(unqlfp,*)(ielrx(i),i=1,nxgreg)
c     Number of finite elements in each v region:      
      read(unqlfp,*)(ielrv(i),i=1,nvgreg)

c     There must be 4 x regions; boundaries will be computed and are not read.
      if(nxgreg.ne.4)then
      write(nofile,*)'Warning: nxgreg=',nxgreg
     ;, ', while software only allows nxgreg=4'
      stop
      end if

C     Compute number of elements & number of abscissae in x and v grids:
      ifielx(1) = 1
      ilaelx(1) = ielrx(1)
      ifielv(1) = 1
      ilaelv(1) = ielrv(1)
      ifiax(1) = 1
      ilaax(1) = 1 + ielrx(1)
      ifiav(1) = 1
      ilaav(1) = 1 + ielrv(1)
        do i = 2, nxgreg
        ifielx(i) = ilaelx(i-1) + 1
        ilaelx(i) = ifielx(i) - 1 + ielrx(i)
        ifiax(i) = ilaax(i-1) + 1
        ilaax(i) = ifiax(i) + ielrx(i)
        end do
        do i = 2, nvgreg
        ifielv(i) = ilaelv(i-1) + 1
        ilaelv(i) = ifielv(i) - 1 + ielrv(i)
        ifiav(i) = ilaav(i-1) + 1
        ilaav(i) = ifiav(i) + ielrv(i)
        end do
      nelrx = ilaelx(nxgreg)
      nelrv = ilaelv(nvgreg)
      nabsx = ilaax(nxgreg)
      nabsv = ilaav(nvgreg)
        do i = 1, nxgreg
          do j = ifiax(i), ilaax(i)
          irxoa(j) = i
          end do
        end do
        do i = 1, nvgreg
          do j = ifiav(i), ilaav(i)
          irvoa(j) = i
          end do
        end do
        
      write(nofile,*)'Number of abscissae in x, v: ', nabsx, nabsv
      
      if(gigdr)then
c     Compute Gaussian abs. and weights on (0,1), 
c     basis functions and their derivatives at Gauss points:
      call gausaw(ngaux, agax, wgax)
      call gausaw(ngauv, agav, wgav)
C       Matrix of Gauss weights:
        do i = 1, ngauv
          do j = 1, ngaux
          wgavx(i,j) = wgav(i) * wgax(j)
          end do
c       Hermite cubic basis functions and deriv.:
        call bafadn(1, agav(i), bafgnv(1,0,i), bafgvs(1,0,i))
        end do
        do i = 1, ngaux
        call bafadn(1, agax(i), bafgnx(1,0,i), bafgxs(1,0,i))
        end do
        do igv = 1, ngauv
          do igx = 1, ngaux
          t = wgavx(igv,igx)
            do i = 1, 4
              do j = 1, 4
              t1 = bafgnv(i,0,igv) * bafgnx(j,0,igx)
              t2 = bafgnv(i,1,igv) * bafgnx(j,0,igx)
              t3 = bafgnv(i,0,igv) * bafgnx(j,1,igx)
              bibj(i,j,igv,igx) = t1
              bipbj(i,j,igv,igx) = t2
              bibjp(i,j,igv,igx) = t3
              wbibj(i,j,igv,igx) = t1 * t
              wbipbj(i,j,igv,igx) = t2 * t
              wbibjp(i,j,igv,igx) = t3 * t
              end do
            end do
          end do
        end do
      end if

      entry rdnxqr
C     ============  
 2000 CONTINUE
c     Read QLFP data for next radius:
    
c     Generalized radius of current magnetic surface:      
      read(unqlfp,*,end=9998,err=9999)rhoq
        if(nraddr.ge.maxrdr)then
        write(nofile,*)'RDEQUI: you are trying to read one radius too much'
     ;//' - I will not comply'
        return
        end if
      nraddr = nraddr + 1
      raqlfp(nraddr) = rhoq
      
C     Find close point to QLFP radius in Cyrano mesh:
      write(nofile,*)'Current QLFP radius: ', raqlfp(nraddr)
      kr = nraddr
      intab = isrchfge(nabsci, abscis, 1, raqlfp(kr))
      irafp(kr) = intab
      write(nofile,*)'It is approximated by Cyrano radius: ', abscis(intab)

c     Compute xn and x element meshes at current radius:
C     Normalized x at separatrix (co-passing):
      xnsep = - 2.d0 * delb(intab) / bmax(intab)
      xmax = B0 / bmin(intab)
      xnb(0,kr) = -1.d0
      xnb(1,kr) = xnsep
      xnb(2,kr) = 0.d0
      xnb(3,kr) = - xnsep
      xnb(4,kr) = 1.d0
        do i = 1, nxgreg
        j = ifiax(i)
        call cuteq(xnb(i-1,kr), xnb(i,kr), ielrx(i), xngta(j,kr))
        xlelg(i,kr) = (xnb(i,kr) - xnb(i-1,kr)) / dfloat(ielrx(i))
        end do
        do i = 1, nabsx
        xgta(i,kr) = xmax * (1.d0 - dabs(xngta(i,kr)))
        end do

c     Read abscissae of v region boundaries (typically 2 regions):
      read(unqlfp,*,end=9994,err=9995)(vrb(i,kr), i = 0, nvgreg)

C     Compute v element mesh at current radius:
        do i = 1, nvgreg
        j = ifiav(i)
        call cuteq(vrb(i-1,kr), vrb(i,kr), ielrv(i), vgta(j,kr))
        vlelg(i,kr) = (vrb(i,kr) - vrb(i-1,kr)) / dfloat(ielrv(i))
        end do

ccc   needrd=.f.: read anyway to skip F0 in input file.
ccc      if(needrd)then
C     ==============
c     Read 4 nodal finite element parameters of distribution function(s):
c     index i=1,2,3,4 corresponds to value of f0, df0/dv, df0/dx, d2f0/dvdx
c     at each node, respectively.
      isp = 1
      kr = nraddr
c     NB: no loop over gdr species, can assume nspgdr=1 for now.
c     NB: Dirk does not repeat the region boundaries on v mesh!
        do j = 1, nvgreg
        j2 = 1
        if(j .eq. 1)j2 = 0
        do jv = ifiav(j) + j2, ilaav(j)
          do ix = 1, nabsx
          read(unqlfp,1000,end=9997,err=9996)(F0(ix,jv,kr,i,isp),i=1,4)
          end do
        end do
        end do
c     Repeat the region boundaries on v mesh:
        do j = 2, nvgreg
        jv = ifiav(j)
          do i = 1, 4
          call dcopy(nabsx, F0(1,jv-1,kr,i,isp), 1, F0(1,jv,kr,i,isp), 1)
          end do
        end do

c     Normalize F0 and derivatives using Cyrano local density:
      ispa = ispgdr(isp)
      s1 = dentab(intab,ispa)
        do i = 1, 4
          do jv = 1, nabsv
            do ix = 1, nabsx
            F0(ix,jv,kr,i,isp) = F0(ix,jv,kr,i,isp) * s1
            end do
          end do
        end do

ccc      else
      if(.not.needrd)then
C     ===================
c     Fill in F0 using the Maxwellian:
      isp = 1
      ispa = ispgdr(isp)
      
      kr = nraddr
      intab = irafp(kr)
      rho = abscis(intab)
      write(nofile,*)'radial position #',kr,'; rho=',raqlfp(kr),
     ;'; approximated by rho=',rho
      s1 = dentab(intab,ispa) / (sqrtpi * vttab(intab,ispa)) ** 3
      s2 = - 2.d0 / vttab(intab,ispa)**2
        do jv = 1, nabsv
        vel = vgta(jv,kr)
        t1 = s1 * dexp(- (vel / vttab(intab,ispa)) ** 2)
        t2 = s2 * vel * t1
          if(isotro(isp))then
          F0(1,jv,kr,1,isp) = t1
          F0(1,jv,kr,2,isp) = t2
          F0(1,jv,kr,3,isp) = 0.d0
          F0(1,jv,kr,4,isp) = 0.d0
          else
          do ix = 1, nabsx
          F0(ix,jv,kr,1,isp) = t1
          F0(ix,jv,kr,2,isp) = t2
          F0(ix,jv,kr,3,isp) = 0.d0
          F0(ix,jv,kr,4,isp) = 0.d0
          end do
          end if
        end do

      end if
C     ======
      write(nofile,*)'RDEQUI: end of filling F0 for nraddr=', nraddr
c     rqlral: input in NAMPLA. If .true., read all radii in QLFP at once;
c     else only read one now, more later as required using calls to ENTRY RDNXQR
      if(rqlral)go to 2000

      return

 9997 write(nofile,*)'RDEQUI reading F0: end-of-file on unit ',unqlfp
      return
 9996 write(nofile,*)'RDEQUI reading F0: read error on unit ',unqlfp
      return
 9994 write(nofile,*)'RDEQUI reading vrb: end-of-file on unit ',unqlfp
      return
 9995 write(nofile,*)'RDEQUI reading vrb: read error on unit ',unqlfp
      return
 9998 write(nofile,*)'RDEQUI: end-of-file on unit ',unqlfp
      return
 9999 write(nofile,*)'RDEQUI: read error on unit ',unqlfp
      return
        
c     mod 3/4/2004
c 1000 format(1h , 4(g13.6,2x))
 1000 format(1h , 4(g14.6,2x))
      
      end