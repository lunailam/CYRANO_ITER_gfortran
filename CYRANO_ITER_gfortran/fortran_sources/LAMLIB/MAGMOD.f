      subroutine magmod(i, influx)

      implicit none
      
      integer i
      
c      complex*16 influx(*)
      include 'pardim.copy'
      complex*16 influx(maxpom)

c     Used in DSHAPE or GENEQ cases:
c     Computes the poloidal modes of rf magnetic field using Fourier coeffs. 
c     generated by CALL FOUCOG(2) and stored in CVC (common COMFOU). 
c     Also uses modes of E.
c     Also computes inward radial flux of Poynting vector: output 'influx'
c
c     INPUT:
c     i is the current radial index in the PLOT tables (!); 
c     yinv, isubr, iel must be predefined.
c     i = 1 at the magnetic axis.

c  Extend: cokpco?

c      include 'pardim.copy'
      include 'dynou2.copy'
      include 'comfou.copy'
      include 'comgeo.copy'
      include 'commod.copy'
      include 'commag.copy'
      include 'compla.copy'
      include 'comswe.copy'
      include 'comrot.copy'
      include 'comsub.copy'
      include 'comphy.copy'

      character*3 eletyp
      
      integer 
     ;  l, l1, j, j2, ic, im, impk, k1, k2, i1, ii, ini, hi, i2
     ;, ind(8), nc(8), ico(8,2)
     ;, ncou
      
      double precision mask(8), cmask(8), ha, af
      
      complex*16 mat(nficom,8,2), a, b, c, fac
     ;, cmat(8,2)
     ;, eeta, epar, etheta, ephi
      
      data
     ;  ini/0/
     ;, ind/1,1,2,3,2,4,5,4/
     ;, nc/5*2,3*1/
     ;, ico/1,1,1,2,1,5,6,5, 3,3,3,4,3,3*0/
     ;, mask /1.d0,0.d0,1.d0,1.d0,0.d0,1.d0,1.d0,0.d0/
     ;, cmask/0.d0,1.d0,0.d0,0.d0,1.d0,0.d0,0.d0,1.d0/
c     ;, ico/1,3,1,2,3,7,8,9 ,4,6,4,5,6,3*0/
           
      save ini, ind, nc, ico, mask, cmask, fac, mat, cmat

      if(ini.eq.0)then
      fac = dcmplx(0.d0, -1.d0 / (omegag * mu0 * rnorm))
      
c      'mat' to take care of factors of i introduced with nfaci, ifaci:      
        do k = 1, 2
          do j = 1, nficom
            do L = 1, 8
            mat(j,L,k) = cun
            end do
          end do
        end do
        do j = 1, nficom
          if(nfaci(j).gt.0)then
            do L = 1, 8
            if(ifaci(j,1).eq.L)mat(j,L,1) = ci
            end do
          end if
        end do
c     8 by 9 matrix for conversions to +,-,//, in compact (8 by 2) storage:
      cmat(1,1) = dcmplx(sqrt2i,0.d0)
      cmat(1,2) = dcmplx(sqrt2i,0.d0)
      cmat(2,1) = dcmplx(sqrt2i,0.d0)
      cmat(2,2) = dcmplx(sqrt2i,0.d0)
      cmat(3,1) = dcmplx(0.d0,-sqrt2i)
      cmat(3,2) = dcmplx(0.d0, sqrt2i)
      cmat(4,1) = dcmplx(0.d0,-sqrt2i)
      cmat(4,2) = dcmplx(0.d0, sqrt2i)
      cmat(5,1) = dcmplx(0.d0,-sqrt2i)
      cmat(5,2) = dcmplx(0.d0, sqrt2i)
      cmat(6,1) = cun
      cmat(7,1) = cun
      cmat(8,1) = cun
      ini = 1
      end if
      
      eletyp = styp(isubr)
	ncou = nmode(iel) - 1

c       i2, ha: for care of magn. axis (corresponding to i = 1)
        if(i.eq.1)then
        i2 = 1
        ha = 1.d0
        else
        i2 = 0
        ha = yinv
        end if
      
        if(eletyp.eq.'M23')then
c       -----------------------
          if(.not.cokpco)then
          hi = 1
          else
          hi = 2
          end if
C       Skip surface element:
        L = 1
          do ic = 1, nficom
      	do j = 1, nns(ic)
            i1 = ins(j,ic)
      	ii = ind(i1)
      	c = mat(ic,i1,hi)
      	a = mask(i1) * c
      	b = cmask(i1) * c
      	L = L + 1
      	  do im = 1, nmode(iel)
      	  m = im - 1 + minf(iel)
	        k1 = max0(-ncou, 1-im)
      	  k2 = min0(ncou, nmode(iel)-im)
cPL2004	        k1 = max0(-ncrot, 1-im)
cPL2004      	  k2 = min0(ncrot, nmode(iel)-im)
      	    do k = k1, k2
      	    mpk = m + k
      	    impk = im + k
                hrtp(ic,i,im) = hrtp(ic,i,im) + cvc(k,L) * xrtp(ii,i,impk) * (a + b * dcmplx(0.d0, dfloat(mpk)))
                end do
              end do
      	end do
          end do

        if(i.eq.1)then
c       Care of magnetic axis:
c       'M23': special expression for dErho/dy
c       Array ERPA computed in OUTRFF
          do ic = 1, nficom
      	do j = 1, nsi(ic)
      	i1 = isi(j,ic)
      	ii = ind(i1)
      	a = mask(i1) * ha
      	b = cmask(i1) * ha
      	L = L + 1
              if(ii.ne.1)then
c             For contributions of Etheta', Ephi' at axis
              ii = ii + i2
      	    do im = 1, nmode(iel)
      	    m = im - 1 + minf(iel)
	          k1 = max0(-ncou, 1-im)
      	    k2 = min0(ncou, nmode(iel)-im)
cPL2004	        k1 = max0(-ncrot, 1-im)
cPL2004      	  k2 = min0(ncrot, nmode(iel)-im)
      	      do k = k1, k2
      	      mpk = m + k
      	      impk = im + k
                  hrtp(ic,i,im) = hrtp(ic,i,im) + cvc(k,L) * xrtp(ii,i,impk) *
     ;            (a + b * dcmplx(0.d0, dfloat(mpk)))
                  end do
                end do
              else
c             For contribution of Erho'
      	    do im = 1, nmode(iel)
      	    m = im - 1 + minf(iel)
	          k1 = max0(-ncou, 1-im)
        	    k2 = min0(ncou, nmode(iel)-im)
cPL2004	        k1 = max0(-ncrot, 1-im)
cPL2004      	  k2 = min0(ncrot, nmode(iel)-im)
      	      do k = k1, k2
      	      mpk = m + k
      	      impk = im + k
                  hrtp(ic,i,im) = hrtp(ic,i,im) + cvc(k,L) * erpa(impk) *
     ;                            (a + b * dcmplx(0.d0, dfloat(mpk)))
                  end do
                end do
              end if
      	end do
          end do
        else
c       Other radial points:
          do ic = 1, nficom
      	do j = 1, nsi(ic)
      	i1 = isi(j,ic)
      	ii = ind(i1)
      	a = mask(i1) * yinv
      	b = cmask(i1) * yinv
	      L = L + 1
      	  do im = 1, nmode(iel)
      	  m = im - 1 + minf(iel)
	        k1 = max0(-ncou, 1-im)
      	  k2 = min0(ncou, nmode(iel)-im)
cPL2004	        k1 = max0(-ncrot, 1-im)
cPL2004      	  k2 = min0(ncrot, nmode(iel)-im)
      	    do k = k1, k2
      	    mpk = m + k
      	    impk = im + k
                hrtp(ic,i,im) = hrtp(ic,i,im) + cvc(k,L) * xrtp(ii,i,impk) *
     ;          (a + b * dcmplx(0.d0, dfloat(mpk)))
                end do
              end do
      	end do
          end do
        end if
c       Normalization:
        do ic = 1, nficom
      	  do im = 1, nmode(iel)
      	  hrtp(ic,i,im) = hrtp(ic,i,im) * fac
          end do
        end do

c     Radial flux (inward) of Poynting vector: Watt in torus, Watt/m in cyl.
        if(cyl)then
        af = - 0.5d0 * twopi
        else
        af = - 0.5d0 * twopi ** 2
        end if
          do im = 1, nmode(iel)
          influx(im) = czero
	    k1 = max0(-ncou, 1-im)
          k2 = min0(ncou, nmode(iel)-im)
cPL2004	        k1 = max0(-ncrot, 1-im)
cPL2004      	  k2 = min0(ncrot, nmode(iel)-im)
      	do k = k1, k2
      	impk = im + k
            influx(im) = influx(im) + cvc(k,1) * (dconjg(xrtp(2,i,im)) * hrtp(3,i,impk) - dconjg(xrtp(4,i,im)) * hrtp(2,i,impk))
            end do
          influx(im) = af * influx(im)
          end do

c     Conversion to +-// modes: (radial deriv. not evaluated)
        l = l + 1
        l1 = l + 1
        do im = 1, nmode(iel)
        eeta = czero
        epar = czero
	  k1 = max0(-ncou, 1-im)
        k2 = min0(ncou, nmode(iel)-im)
cPL2004	        k1 = max0(-ncrot, 1-im)
cPL2004      	  k2 = min0(ncrot, nmode(iel)-im)
          do k = k1, k2
          impk = im + k
          etheta = xrtp(2,i,impk)
          ephi = xrtp(4,i,impk)
          eeta = eeta + etheta * cvc(k,L) - ephi * cvc(k,L1)
          epar = epar + etheta * cvc(k,L1) + ephi * cvc(k,L)
          end do
        xpmp(1,i,im) = (xrtp(1,i,im) + ci * eeta) * sqrt2i
        xpmp(3,i,im) = (xrtp(1,i,im) - ci * eeta) * sqrt2i
        xpmp(5,i,im) = epar
        end do
        
        else if(eletyp.eq.'HEC')then
c       ----------------------------
c       HRTP will receive rho, eta, // components.

        L = 1
          do ic = 1, nficom
            do j = 1, nns(ic)
            i1 = ins(j,ic)
            a = mask(i1)
            b = cmask(i1)
            L = L + 1
              do j2 = 1, nc(i1)
              c = cmat(i1,j2)
              ii = ico(i1,j2)
                do im = 1, nmode(iel)
                m = im - 1 + minf(iel)
	          k1 = max0(-ncou, 1-im)
      	    k2 = min0(ncou, nmode(iel)-im)
cPL2004	        k1 = max0(-ncrot, 1-im)
cPL2004      	  k2 = min0(ncrot, nmode(iel)-im)
                  do k = k1, k2
                  mpk = m + k
                  impk = im + k
                  hrtp(ic,i,im) = hrtp(ic,i,im) + cvc(k,L) * c * (a + b * dcmplx(0.d0, dfloat(mpk))) * xpmp(ii,i,impk)
                  end do
                end do
              end do
            end do
          end do

          do ic = 1, nficom
            do j = 1, nsi(ic)
            i1 = isi(j,ic)
            a = mask(i1) * ha
            b = cmask(i1) * ha
            L = L + 1
              do j2 = 1, nc(i1)
              c = cmat(i1,j2)
              ii = ico(i1,j2) + i2
                do im = 1, nmode(iel)
                m = im - 1 + minf(iel)
  	          k1 = max0(-ncou, 1-im)
      	    k2 = min0(ncou, nmode(iel)-im)
cPL2004	        k1 = max0(-ncrot, 1-im)
cPL2004      	  k2 = min0(ncrot, nmode(iel)-im)
                  do k = k1, k2
                  mpk = m + k
                  impk = im + k
                  hrtp(ic,i,im) = hrtp(ic,i,im) + cvc(k,L) * c * (a + b * dcmplx(0.d0, dfloat(mpk))) * xpmp(ii,i,impk)
                  end do
                end do
              end do
            end do
          end do

          do ic = 1, nficom
            do im = 1, nmode(iel)
            hrtp(ic,i,im) = hrtp(ic,i,im) * fac
            end do
          end do

c     Radial flux (inward) of Poynting vector: Watt in torus, Watt/m in cyl.
c     XPMP: +,-,// comp. of E; HRTP: rho,eta,// comp.of H.
c     Using conj(Eeta) H// - conj(E//) Heta
        if(cyl)then
        af = - 0.5d0 * twopi
        else
        af = - 0.5d0 * twopi ** 2
        end if
          do im = 1, nmode(iel)
          influx(im) = czero
	    k1 = max0(-ncou, 1-im)
          k2 = min0(ncou, nmode(iel)-im)
cPL2004	        k1 = max0(-ncrot, 1-im)
cPL2004      	  k2 = min0(ncrot, nmode(iel)-im)
            do k = k1, k2
            impk = im + k
            influx(im) = influx(im) + cvc(k,1) * (
     ;      dconjg(- ci * sqrt2i * (xpmp(1,i,im) - xpmp(3,i,im))) * hrtp(3,i,impk) - dconjg(xpmp(5,i,im)) * hrtp(2,i,impk))
            end do
          influx(im) = af * influx(im)
          end do

c     Conversion to rtp modes: (radial deriv. not evaluated)
        L = L + 1
        L1 = L + 1
        do im = 1, nmode(iel)
        xrtp(1,i,im) = (xpmp(1,i,im) + xpmp(3,i,im)) * sqrt2i
        etheta = czero
        ephi = czero
	  k1 = max0(-ncou, 1-im)
        k2 = min0(ncou, nmode(iel)-im)
cPL2004	        k1 = max0(-ncrot, 1-im)
cPL2004      	  k2 = min0(ncrot, nmode(iel)-im)
          do k = k1, k2
          impk = im + k
          eeta = (xpmp(1,i,impk) - xpmp(3,i,impk)) * sqrt2i * (- ci)
          epar = xpmp(5,i,impk)
          etheta = etheta + eeta * cvc(k,L) + epar * cvc(k,L1)
          ephi = ephi - eeta * cvc(k,L1) + epar * cvc(k,L)
          end do
        xrtp(2,i,im) = etheta
        xrtp(4,i,im) = ephi
        end do

        end if
c       ------

      return
      end
