      subroutine read_QLFP
      
      implicit none

      include 'pardim.copy'
      include 'comfic.copy'
      include 'comfin.copy'
      include 'compla.copy'
      include 'comgeo.copy'
      include 'commag.copy'
      include 'comswe.copy'
      include 'comgdr.copy'
      include 'comin2.copy'
      include 'comphy.copy'
      include 'comreg.copy'	! ern
      include 'cokpco.copy'	! ern


C     Reads finite element coefficients of equilibrium distribution(s)
C     generated by QLFP code.
C     Case of bicubic finite elements in (v,x) constants of the motion,
C     i.e. there are 4 parameters per mesh node.   

cERN	NEW	31/05/05: Input file QLFP_data.txt MODIFIED!

c	All QLFP distribution data was removed from the main file and 
c	transfered to sub-files per magnetic surface.
c	The general input file QLFP_data.txt now contains the following parameters:
c	   1) Number of x and v regions
c	   2) Number of elements in x-regions and v-regions
c	   3) Number of magnetic surfaces (radii) given by the QLFP code
c	For each magnetic surface, we have:
c	   1) Radius(rho) of magnetic surface
c	   2) v-region limits for the given surface
c	   3) The name of the file (a string) that contains the F0 
c		  data for the given radius (e.g. QLFPdist_r0400.dat).
c
c	In case needrd=FALSE, the QLFP radii will be used to compute the
c	analytical Maxwellian distribution and interpolation to CYRANO abscissa 
c	points will take place.
     
      logical needrd
      
      integer kr, jv, ix, isp, ispa, i, j, igx, igv, j2
     ;, isrchfge, nradqlfp, jrad
     
      double precision t, t1, t2, t3, s1, s2, xmax, vel, rhoq

	character(18) :: F0_file
	character(100) :: FILE_NAME
	integer :: OpenStat

      needrd = .false.
      do i = 1, nspgdr
      if(.not. maxwdr(i))needrd = .true.
      end do

      if(needrd)then
         write(NOFILE,*)
     ;   'Reading grid data and equilibrium distribution(s) on unit ',unqlfp
      else
         write(NOFILE,*)'Reading grid data on unit ',unqlfp
         write(NOFILE,*)
     ;   'A sampled Maxwellian will be used to generate dielectric response'
      end if
      write(NOFILE,*)'for species # ',(ispgdr(i),i=1,nspgdr)
     

c     Current number of magnetic surfaces:
      nraddr = 0

c     Read radius-independent data:
c@    (read only once at beginning of the run) @      

c     Number of regions in x and in v:      
      read(unqlfp,*)nxgreg, nvgreg
c     Number of finite elements in each x region:      
      read(unqlfp,*)(ielrx(i),i=1,nxgreg)
c     Number of finite elements in each v region:      
      read(unqlfp,*)(ielrv(i),i=1,nvgreg)

c     There must be 4 x regions; boundaries will be computed and are not read.
      if(nxgreg.ne.4)then
         write(nofile,*)'Warning: nxgreg=',nxgreg,', while software only allows nxgreg=4'
	   print *, 'STOP at read_QLFP line 87!'
         stop
      end if

c	-----------------------------------------------
cERN	NEW(31/05/05) Read number of QLFP magnetic surfaces
	read(unqlfp,*),nradqlfp
      if(nradqlfp.gt.maxrdr)then
         write(nofile,*)'Warning: nradqlfp=',nradqlfp,' exceeds max. limit: maxrdr =',maxrdr
         print *, 'STOP at read_QLFP line 95!'
	   stop
      end if
c	-----------------------------------------------


C     Compute number of elements & number of abscissae in x and v grids:
      ifielx(1) = 1
      ilaelx(1) = ielrx(1)
      ifielv(1) = 1
      ilaelv(1) = ielrv(1)
      ifiax(1) = 1
      ilaax(1) = 1 + ielrx(1)
      ifiav(1) = 1
      ilaav(1) = 1 + ielrv(1)
        do i = 2, nxgreg
        ifielx(i) = ilaelx(i-1) + 1
        ilaelx(i) = ifielx(i) - 1 + ielrx(i)
        ifiax(i) = ilaax(i-1) + 1
        ilaax(i) = ifiax(i) + ielrx(i)
        end do
        do i = 2, nvgreg
        ifielv(i) = ilaelv(i-1) + 1
        ilaelv(i) = ifielv(i) - 1 + ielrv(i)
        ifiav(i) = ilaav(i-1) + 1
        ilaav(i) = ifiav(i) + ielrv(i)
        end do
      nelrx = ilaelx(nxgreg)
      nelrv = ilaelv(nvgreg)
      nabsx = ilaax(nxgreg)
      nabsv = ilaav(nvgreg)
        do i = 1, nxgreg
          do j = ifiax(i), ilaax(i)
          irxoa(j) = i
          end do
        end do
        do i = 1, nvgreg
          do j = ifiav(i), ilaav(i)
          irvoa(j) = i
          end do
        end do
        
      write(nofile,*)'Number of abscissae in x, v: ', nabsx, nabsv
      
      if(gigdr)then
c     Compute Gaussian abs. and weights on (0,1), 
c     basis functions and their derivatives at Gauss points:
      call gausaw(ngaux, agax, wgax)
      call gausaw(ngauv, agav, wgav)
C       Matrix of Gauss weights:
        do i = 1, ngauv
          do j = 1, ngaux
          wgavx(i,j) = wgav(i) * wgax(j)
          end do
c       Hermite cubic basis functions and deriv.:
        call bafadn(1, agav(i), bafgnv(1,0,i), bafgvs(1,0,i))
        end do
        do i = 1, ngaux
        call bafadn(1, agax(i), bafgnx(1,0,i), bafgxs(1,0,i))
        end do
        do igv = 1, ngauv
          do igx = 1, ngaux
          t = wgavx(igv,igx)
            do i = 1, 4
              do j = 1, 4
              t1 = bafgnv(i,0,igv) * bafgnx(j,0,igx)
              t2 = bafgnv(i,1,igv) * bafgnx(j,0,igx)
              t3 = bafgnv(i,0,igv) * bafgnx(j,1,igx)
              bibj(i,j,igv,igx) = t1
              bipbj(i,j,igv,igx) = t2
              bibjp(i,j,igv,igx) = t3
              wbibj(i,j,igv,igx) = t1 * t
              wbipbj(i,j,igv,igx) = t2 * t
              wbibjp(i,j,igv,igx) = t3 * t
              end do
            end do
          end do
        end do
      end if

 
cERN	31/05/05 Next entry substituted by loop over QLFP radii 
cERN      entry rdnxqr
cERN c     ============  
cERN  2000 CONTINUE
c     Read QLFP data for next radius:

	do kr = 1, nradqlfp	! (loop over QLFP radii)
c	------------------------------------------------------------------
    
c        Read generalized radius of current magnetic surface:      
	   read(unqlfp,*,end=9998,err=9999)rhoq
         raqlfp(kr) = rhoq
         nraddr = nraddr + 1
cERN     kr = nraddr

c        Find close point to QLFP radius in Cyrano mesh:
         write(nofile,*)'Current QLFP radius: ', raqlfp(kr)
         intab = isrchfge(nabsci, abscis, 1, raqlfp(kr))
         irafp(kr) = intab
         write(nofile,*)'Approximated CYRANO radius: ', abscis(intab)

c        Compute xn and x element meshes at current radius:
C        Normalized x at separatrix (co-passing):
         xnsep = - 2.d0 * delb(intab) / bmax(intab)
         xmax = B0 / bmin(intab)
         xnb(0,kr) = -1.d0
         xnb(1,kr) = xnsep
         xnb(2,kr) = 0.d0
         xnb(3,kr) = - xnsep
         xnb(4,kr) = 1.d0
         do i = 1, nxgreg
            j = ifiax(i)
            call cuteq(xnb(i-1,kr), xnb(i,kr), ielrx(i), xngta(j,kr))
            xlelg(i,kr) = (xnb(i,kr) - xnb(i-1,kr)) / dfloat(ielrx(i))
         end do
         do i = 1, nabsx
            xgta(i,kr) = xmax * (1.d0 - dabs(xngta(i,kr)))
         end do

c        Read abscissae of v region boundaries (typically 2 regions):
         read(unqlfp,*,end=9994,err=9995)(vrb(i,kr), i = 0, nvgreg)

C        Compute v element mesh at current radius:
         do i = 1, nvgreg
            j = ifiav(i)
            call cuteq(vrb(i-1,kr), vrb(i,kr), ielrv(i), vgta(j,kr))
            vlelg(i,kr) = (vrb(i,kr) - vrb(i-1,kr)) / dfloat(ielrv(i))
         end do

cERN	   NEW(31/05/05) 
c	   Read file name where F0 data for current radius is stored
	   read(unqlfp,'(A18)')F0_file

         if(needrd)then
C        ==============
cERN		  NEED TO UPDATE DATA READING WITH CORRECT FILENAME F0_file!
c		  ----------------------------------------------------------

c		  Read 4 nodal finite element parameters of distribution function(s):
c		  index i=1,2,3,4 corresponds to value of f0, df0/dv, df0/dx, d2f0/dvdx
c		  at each node, respectively.
		  isp = 1
cERN		  kr = nraddr
c		  NB: no loop over gdr species, can assume nspgdr=1 for now.
c		  NB: Dirk does not repeat the region boundaries on v mesh!
		  do j = 1, nvgreg
			 j2 = 1
			 if(j .eq. 1)j2 = 0
			 do jv = ifiav(j) + j2, ilaav(j)
				do ix = 1, nabsx
				   read(unqlfp,1000,end=9997,err=9996)(F0(ix,jv,kr,i,isp),i=1,4)
				end do
			 end do
		  end do

c		  Repeat the region boundaries on v mesh:
		  do j = 2, nvgreg
		     jv = ifiav(j)
			 do i = 1, 4
				call dcopy(nabsx, F0(1,jv-1,kr,i,isp), 1, F0(1,jv,kr,i,isp), 1)
			 end do
		  end do

c		  Normalize F0 and derivatives using Cyrano local density:
cERN		  Factor 1.0d20 added here
		  ispa = ispgdr(isp)
		  s1 = 1.0d20*dentab(intab,ispa)
c		  do i = 1, 4
c			 do jv = 1, nabsv
c				do ix = 1, nabsx
		  F0(1:nabsx,1:nabsv,kr,1:4,isp) = F0(1:nabsx,1:nabsv,kr,1:4,isp) * s1
c				end do
c		     end do
c	      end do

         else	   ! (needrd=FALSE)
c	   ========================

c		  Fill in F0 using the analytical Maxwellian:
cERN	      31/05/05: Compute F0 for all QLFP radii (given in QLFP_data.txt)
		  isp = 1
		  ispa = ispgdr(isp)
cERN		  kr = nraddr
		  intab = irafp(kr)
		  rho = abscis(intab)
c		  write(nofile,*)'radial position #',kr,'; rho=',raqlfp(kr),
c		  ;'; approximated by rho=',rho
		  s1 = 1.d20*dentab(intab,ispa) / (sqrtpi * vttab(intab,ispa)) ** 3
		  s2 = - 2.d0 / vttab(intab,ispa)**2
		  do jv = 1, nabsv
			 vel = vgta(jv,kr)
			 t1 = s1 * dexp(- (vel / vttab(intab,ispa)) ** 2)
			 t2 = s2 * vel * t1
			 if(isotro(isp))then
cERN		same for all x-values (vectorized)
				F0(1:nabsx,jv,kr,1,isp) = dmax1(t1,1.d-40)
				F0(1:nabsx,jv,kr,2,isp) = dmin1(t2,-1.d-40)
				F0(1:nabsx,jv,kr,3,isp) = 0.d0
				F0(1:nabsx,jv,kr,4,isp) = 0.d0
			 else
cERN		Does not look very anisotropic
				do ix = 1, nabsx
				   F0(ix,jv,kr,1,isp) = t1
				   F0(ix,jv,kr,2,isp) = t2
				   F0(ix,jv,kr,3,isp) = 0.d0
				   F0(ix,jv,kr,4,isp) = 0.d0
				end do
			 end if
		  end do	! jv


         end if	!(needrd)
C        ==================

      write(nofile,*)'RDEQUI: end of filling F0 for nraddr=', nraddr
c     rqlral: input in NAMPLA. If .true., read all radii in QLFP at once;
c     else only read one now, more later as required using calls to ENTRY RDNXQR

	end do	! kr = 1, nradqlfp (loop over QLFP radii)
c	----------------------------------------------------------------------

cERN      if(rqlral)go to 2000


cERN	Output added 23/06/05
         FILE_NAME = "../../M12run/QLFP_distribution.dat" 
			open (UNIT = 77, FILE = FILE_NAME, STATUS = "REPLACE",
c     ;			  BUFFERED='YES', BLOCKSIZE = 32*512, BUFFERCOUNT = 50, 
     ;              IOSTAT = OpenStat, ACTION = "WRITE")
	              if (OpenStat > 0) then
		              print *, 'Error writing file: ', FILE_NAME
	                  stop
				  end if
	  
	  
	  				  write(77,*),"RAW (v,xn) data for Non-Maxwellians (read_QLFP)"
					  write(77,*), nradqlfp, nabsv, nabsx

				  do kr = 1, nradqlfp	! ---------------------------------

					  write(77,*) ' radius =', raqlfp(kr)

						write(77,*)'v'				
						write(77,*),nabsv
						do jv = 1,nabsv
						write(77,*) vgta(jv,kr) 
						end do

						write(77,*)'xn'				
						write(77,*),nabsx
						do ix = 1,nabsx
						write(77,*) xgta(ix,kr) 
						end do

						write(77,*)'F0(v:lines,xn:cols)'				
						do jv = 1,nabsv
						write(77,2222) vgta(jv,kr),F0(1:nabsx,jv,kr,1,isp)
						end do

						write(77,*)'dF0/dv(v:lines,xn:cols)'				
						do jv = 1,nabsv
						write(77,2222) vgta(jv,kr), F0(1:nabsx,jv,kr,2,isp)
						end do

					end do	! kr = 1, nradqlfp  -----------------------

	close (77)
c
c








      return

 9997 write(nofile,*)'RDEQUI reading F0: end-of-file on unit ',unqlfp
      return
 9996 write(nofile,*)'RDEQUI reading F0: read error on unit ',unqlfp
      return
 9994 write(nofile,*)'RDEQUI reading vrb: end-of-file on unit ',unqlfp
      return
 9995 write(nofile,*)'RDEQUI reading vrb: read error on unit ',unqlfp
      return
 9998 write(nofile,*)'RDEQUI: end-of-file on unit ',unqlfp
      return
 9999 write(nofile,*)'RDEQUI: read error on unit ',unqlfp
      return
        
c     mod 3/4/2004
c 1000 format(1h , 4(g13.6,2x))
 1000 format(1h , 4(g14.6,2x))
 2222 format(200(g18.6))        
      end
